<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript笔记"><meta name="keywords" content="JS"><meta name="author" content="Doug Flands"><meta name="copyright" content="Doug Flands"><title>JavaScript笔记 | Flands Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '7.1.1'
} </script><meta name="generator" content="Hexo 7.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">其他代码说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">选择语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">循环遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.4.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">事件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA"><span class="toc-number">3.1.</span> <span class="toc-text">弹出提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">打开新窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.</span> <span class="toc-text">时间对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">数学方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.8.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-number">3.9.</span> <span class="toc-text">正则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSON"><span class="toc-number">4.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">4.1.</span> <span class="toc-text">JS高级篇</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">原始类型和对象类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%9C-%E7%89%B9%E6%AE%8A"><span class="toc-number">5.3.</span> <span class="toc-text">隐式类型转换结果(特殊)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">类型识别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-number">6.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">6.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-number">6.3.</span> <span class="toc-text">Object.prototype.toString.call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">6.4.</span> <span class="toc-text">constructor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#function-a-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.1.1.</span> <span class="toc-text">function a(){}  函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-a-function-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.2.</span> <span class="toc-text">var a &#x3D; function (){}  函数定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arguments"><span class="toc-number">7.2.1.</span> <span class="toc-text">arguments</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">7.3.</span> <span class="toc-text">函数传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#first-class-function"><span class="toc-number">7.4.</span> <span class="toc-text">first-class function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">构造方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">8.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.3.</span> <span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">9.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">闭包的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">10.2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.1.</span> <span class="toc-text">定义方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">10.3.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://flands.com/avatar/192.jpg"></div><div class="author-info__name text-center">Doug Flands</div><div class="author-info__description text-center">Flands</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Flands Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">JavaScript笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-05-15</time></div><div class="article-container" id="post-content"><p>笔记标题啥的有点乱，就这样看吧，注释也有。</p>
<h1 id="其他代码说明"><a href="#其他代码说明" class="headerlink" title="其他代码说明"></a>其他代码说明</h1><pre><code>`&lt;li&gt;第$&#123;j+1&#125;&lt;/li&gt;`					//$&#123;&#125;
&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
console.log()						//输出日志
            
</code></pre>
<span id="more"></span>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><pre><code>if(str) &#123;&#125;
else if() &#123;&#125;
else &#123;&#125;
a&lt;1?为真结果:为假结果
</code></pre>
<h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><pre><code>switch() &#123;
case &#39;1&#39;: 代码 break;
default:都不符合;&#125;
</code></pre>
<h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><pre><code>for(var i=0;i&lt;=Class.length;i++)&#123;
            Class[i].checked=true;		//选中
        &#125;
while()&#123;&#125;
do&#123;	&#125;while()
</code></pre>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><pre><code>try&#123;if() throw &quot;自定义的错误提示&quot;&#125;
catch()&#123;&#125;
finally&#123;无论如何都执行&#125;
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>function aaaa()
  &#123;
     alert(&quot;调用函数&quot;);
  &#125;
var length = arguments.length		//多个传参

&lt;input type=&quot;button&quot;  value=&quot;点击我&quot; onclick=&quot;aaaa();&quot; /&gt;  

参数传递
值传递只传递值，参数为对象时是引用传递

function P(x,y)&#123;
    this.x = x;
    this.y = y;
//公共方法
P.prototype.move = function(sX,sY)&#123;
    this.x += sX;
    this.y += sY;
&#125;
&#125;

var point = new P(1,1)		//point以P为原型克隆创建函数，这种方法避免P.move输出function
P.move(2,1)					//从公共属性里查找方法
</code></pre>
<h1 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h1><h2 id="弹出提示"><a href="#弹出提示" class="headerlink" title="弹出提示"></a>弹出提示</h2><pre><code>alert(&quot;str&quot;);						//弹出提示字符串
alert(hello);						//弹出提示变量
prompt(&quot;提示&quot;，&quot;默认输入值&quot;)；			//可输入值对话框
confirm(&quot;str&quot;)；						//消息确定取消对话框
</code></pre>
<h2 id="打开新窗口"><a href="#打开新窗口" class="headerlink" title="打开新窗口"></a>打开新窗口</h2><pre><code>window.open(&#39;URL&#39;, &#39;窗口名称&#39;, &#39;参数字符串&#39;)
名称.close();		//关闭

窗口名称
_blank：在新窗口显示目标网页
_self：在当前窗口显示目标网页
_top：框架网页中在上部窗口中显示目标网页
</code></pre>
<table>
<thead>
<tr>
<th>代码</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>top(width)</td>
<td>Number</td>
<td>方向上间隔像素</td>
</tr>
<tr>
<td>menubar</td>
<td>yes,no</td>
<td>菜单</td>
</tr>
<tr>
<td>toolbar</td>
<td>yes,no</td>
<td>工具条</td>
</tr>
<tr>
<td>scrollbars</td>
<td>yes,no</td>
<td>滚动条</td>
</tr>
<tr>
<td>status</td>
<td>yes,no</td>
<td>状态栏</td>
</tr>
</tbody></table>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>onclick 		//鼠标单击
onmouseover  	//鼠标经过
onmouseout 		//鼠标移开
onchange 		//文本框内容改变
onselect		//文本框内容被选中
onfocus			//光标聚集
onblur			//光标离开
onload			//网页导入
onunload		//关闭网页
</code></pre>
<h2 id="时间对象"><a href="#时间对象" class="headerlink" title="时间对象"></a>时间对象</h2><pre><code>var date = new Date(2012, 10, 1);	//获取时间
date.get/set 	返回\设置	
FullYear()		//年份(四位数表示)
Year()			//年份
Month()			//月，0为1月
Date()			//日
Hours()			//小时，24制
Minutes()		//分钟
Seconds()		//秒钟
Time()			//时间(毫秒计)，以此转为num后传入new Date()即可
</code></pre>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code>string
String()								//转数字
\&quot;										//转义
.toLowerCase()							//转为小写字母
.toUpperCase()							//转为大写字母
.charAt(string.length-1)				//返回最后一个字符
.indexOf(a, b)							//检索a(区分大小写)，从b位置找，可设.length-1
.indexOf(&quot;o&quot;,string.indexOf(&quot;o&quot;)+1))	//检索第二个,当无时，返回-1
.split(&quot;&quot;,3)							//分割每个字符，分割3次，可为正则
.slice(起点,终点(可为-1))					//和下面一样
.substring( 起点 ， 终点(不包含)? )
.substr(起点,长度)
.search(re)							//正则，返回索引位置，未找到为-1
.match(re)							//返回匹配到的字符，+g为全局，返回所有，未找到为null
.replace(re|字符串,替换字符串)      //.replace(/\s+/g, &quot;&quot;)替换空字符串
</code></pre>
<h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><pre><code>parseInt(&#39;&#39;)					//字符串转整数,遇到字母停止转换
parseFloat(&#39;&#39;)					//字符串转浮点
Number(&#39;100.1&#39;)					//有字母就NaN
(100.123).toFixed(2)   			//保留小数点
</code></pre>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><pre><code>.constructor()				//获取对象由哪种方法构造
.toString()					//转字符串方法
.hasOwnprorerty(&quot;属性&quot;)		//是否包含某种属性，返回布尔值
</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>arr

原始数组被改变
.forEach()					//遍历数组，传入函数fun(item)&#123;a.b +=5;&#125;
.reverse()					//倒序
.sort()						//排序，a-b低-高，b-a高-低
.push()						//在最后添加数组
.unshift()					//在最前添加数组
.shift()					//取出第一个元素，且被删除
.pop()						//取出最后一个元素，且被删除
.splice(索引位置，删掉几个，插入元素)

对原数组没有修改
.slice(包含开始，不包含结束)	//获取索引数组数据
newArr.concat()					//合并数组
.join(&quot;;&quot;)					//合并数组，用分号隔开
.map(函数)					//返回新的数组
.reduce(函数,初始值)			//返回一个数值，求和
</code></pre>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><pre><code>/1/.test(&#39;1&#39;)				//返回true|flase，只要包含则true
</code></pre>
<table>
<thead>
<tr>
<th>匹配一个位置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>起始位置</td>
</tr>
<tr>
<td>$</td>
<td>结尾位置</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>匹配一类字符串</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]</td>
<td>abc中一个</td>
</tr>
<tr>
<td>[0-9]</td>
<td>一个数字</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>非数字的一个字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>一个字母</td>
</tr>
<tr>
<td>.</td>
<td>任一字符(换行除外)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊意义的字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>等价[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>空白符</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>[A-Za-z0-9]</td>
</tr>
<tr>
<td>(a</td>
<td>b)或[ab]</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>{m,n}</td>
<td>m到n次</td>
</tr>
<tr>
<td>*</td>
<td>无穷次{0,}</td>
</tr>
<tr>
<td>?</td>
<td>{0,1}</td>
</tr>
<tr>
<td>+</td>
<td>{1,}</td>
</tr>
<tr>
<td>\w</td>
<td>[A-Za-z0-9]</td>
</tr>
</tbody></table>
<p>一般添加’.’来匹配到换行符，然后返回false开始回溯<br>贪婪模式:根据表达式去匹配尽可能多的内容。回溯:当匹配为false时则回溯到倒数第一个true，返回结果</p>
<p>非贪婪模式(惰性模式)，添加’?’:匹配尽可能少的内容。回溯:匹配到第一个true就结束</p>
<p>独占模式，添加’+’:同贪婪，匹配为false不会回溯，直接结束匹配</p>
<table>
<thead>
<tr>
<th>捕获</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>()</td>
<td>捕获</td>
</tr>
<tr>
<td>(?:)</td>
<td>不捕获</td>
</tr>
</tbody></table>
<pre><code>str.match(正则表达式)		//捕获字符串
str.replace(正则,&#39;替换内容$1&#39;)		//正则捕获的结果保存在$里，如果捕获5，则自动改为$5
</code></pre>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><pre><code>JSON.parse(文本,转换函数?)					//JSON转JS对象，IE6,7不支持
JSON.stringify(数值,[想要传入的属性名称]?)		//JS对象转JSON
IE6.7支持方式
if (!window.JSON)&#123;
    window.JSON = &#123;
        parse: function(sJSON)&#123;
            return eval(&#39;(&#39; +s.JSON+&#39;)&#39;);
        &#125;
        stringify: function()&#123;
            //...
        &#125;
    &#125;;
&#125;
</code></pre>
<h2 id="JS高级篇"><a href="#JS高级篇" class="headerlink" title="JS高级篇"></a>JS高级篇</h2><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="原始类型和对象类型"><a href="#原始类型和对象类型" class="headerlink" title="原始类型和对象类型"></a>原始类型和对象类型</h2><p>直接定义为原始类型，存储于栈内存<br><code> var a=123;</code>
栈内存的复制为深拷贝，创建新的内存值与变量   </p>
<p>对象类型存储于堆内存，{}[]
创建新对象为浅拷贝，指向原有变量的堆内存</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ul>
<li>数字+字符串&#x3D;字符串</li>
<li>.转为对象类型</li>
</ul>
<h2 id="隐式类型转换结果-特殊"><a href="#隐式类型转换结果-特殊" class="headerlink" title="隐式类型转换结果(特殊)"></a>隐式类型转换结果(特殊)</h2><table>
<thead>
<tr>
<th>类型</th>
<th>原值</th>
<th>布尔</th>
<th>数字</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>Undefined</td>
<td></td>
<td>NaN</td>
</tr>
<tr>
<td>Null</td>
<td>null</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>String</td>
<td>“”</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>String</td>
<td>“la”</td>
<td></td>
<td>NaN</td>
</tr>
<tr>
<td>Number</td>
<td>NaN</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td>{}</td>
<td>true</td>
<td>NaN</td>
</tr>
<tr>
<td>有数字的几乎都为true，false的Number为0，原值多少String就是多少，Object为类型+值。所有的对象都为true。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>转换方式:Number(num.value)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Number(),String(),Boolean()</li>
<li>parseInt(),parseFloat()		&#x2F;&#x2F;转为整数，浮点</li>
<li>!,!!		&#x2F;&#x2F;两个!!取到对象的布尔值</li>
</ul>
<h1 id="类型识别"><a href="#类型识别" class="headerlink" title="类型识别"></a>类型识别</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><pre><code>typeof &quot;jerry&quot;;	//&quot;string&quot;
typeof undefined;//&quot;undefined&quot;
typeof null;//&quot;object&quot;
typeof &#123;name:&quot;a&quot;&#125;;//&quot;object&quot;
typeof function()&#123;&#125;
</code></pre>
<ul>
<li>可以识别标准类型，Null除外</li>
<li>不能识别具体的对象类型，function除外</li>
</ul>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre><code>[] instanceof Array	//true
/\d/ instanceof RegExp //true
1 instanceof Number //false
&quot;jerry&quot; instanceof String //false
</code></pre>
<ul>
<li>判别所有对象类型</li>
<li>不能判别原始类型</li>
</ul>
<h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h2><pre><code>function type(obj)&#123;
    return Object.prototype.toString.call(obj).slice(8,-1)&#125;
</code></pre>
<ul>
<li>识别标准类型以及内置对象类型</li>
<li>不能识别自定义的对象类型</li>
</ul>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><ul>
<li>构造对象的构造函数本身</li>
<li>判断标准类型(undefined&#x2F;Null除外)</li>
<li>判别内置对象类型</li>
<li>判别自定义对象类型</li>
</ul>
<h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>JS执行前会解释部分代码</p>
<h3 id="function-a-函数声明"><a href="#function-a-函数声明" class="headerlink" title="function a(){}  函数声明"></a>function a(){}  函数声明</h3><ul>
<li>可以在函数定义前被调用(函数定义前置)</li>
<li>同名以最后的为准</li>
<li>作用域:逐级向上查询</li>
</ul>
<h3 id="var-a-function-函数定义"><a href="#var-a-function-函数定义" class="headerlink" title="var a &#x3D; function (){}  函数定义"></a>var a &#x3D; function (){}  函数定义</h3><ul>
<li>不能再函数定义前调用</li>
<li>作用域:只能访问本地作用域和全局作用域</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ul>
<li>函数调用模式 add(1)<br>this指向全局</li>
<li>方法调用模式 add.a(1)<br>this指向调用者</li>
<li>构造函数调用模式 <code>var a = new Function()</code><br>this指向被构造的对象</li>
<li>apply(call)调用模式<br>this指向第一个参数</li>
</ul>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><ul>
<li>Array-like</li>
</ul>
<ul>
<li>arguments[index]</li>
<li>arguments.lenth</li>
</ul>
<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><ul>
<li>按值传递</li>
</ul>
<ul>
<li>原始类型变量</li>
</ul>
<ul>
<li>按共享传递</li>
</ul>
<ul>
<li>对象类型</li>
</ul>
<h2 id="first-class-function"><a href="#first-class-function" class="headerlink" title="first-class function"></a>first-class function</h2><ul>
<li>函数作为参数</li>
</ul>
<ul>
<li>异步回调函数</li>
</ul>
<ul>
<li>函数作为返回值</li>
</ul>
<ul>
<li><code>function.prororype.bind()</code>接受第一个参数，绑定在var对象中，执行var对象或者给var对象传入参数才会执行</li>
</ul>
<ul>
<li>柯里化:接受一个参数,return一个函数用来接受余下函数</li>
</ul>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul>
<li>原型：以一个具体函数为对象创建一个对象</li>
<li>类:抽象出一个对象，以此创建一个类</li>
</ul>
<h2 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h2><ul>
<li>Object.create(proto)</li>
</ul>
<ul>
<li>proto 一个对象，作为新创建对象的原型，原型为_proto_</li>
</ul>
<ul>
<li>构造函数</li>
</ul>
<ul>
<li>使用prototype设置原型</li>
<li>使用new创建对象&#96; var a &#x3D; new b(‘’)</li>
<li>创建后构造函数中有原函数名的方法</li>
</ul>
<ul>
<li><code>obj.hasOwnProperty(&#39;属性&#39;)</code>判断属性是否是自身的属性，返回布尔值</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>构造出的的函数删除修改自身属性都不会影响原型，且可以访问原型上的方法</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li>静态作用域</li>
</ul>
<ul>
<li>称为词法作用域</li>
<li>由程序定义的位置决定</li>
</ul>
<ul>
<li>动态作用域</li>
</ul>
<ul>
<li>查找栈内最后的对象</li>
</ul>
<ul>
<li>词法环境</li>
</ul>
<ul>
<li>形参</li>
<li>函数声明</li>
<li>变量</li>
<li>…</li>
</ul>
<ul>
<li>环境记录初始化:声明提前，匿名函数指向父元素</li>
</ul>
<ul>
<li>函数声明会因为初始化时而被定义作用域</li>
<li>函数定义会随着环境的改变而改变作用域</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>子函数访问父函数的对象的作用域</p>
<ul>
<li>保存函数的执行状态</li>
<li>封装</li>
</ul>
<ul>
<li>保存在return{}内使用各种方法</li>
</ul>
<ul>
<li><p>性能优化</p>
<p>  function add(){
  var i &#x3D; 0;
  return function(){
      alert(i++);
      }
  }
  var f&#x3D; add();
  f();
  f();</p>
</li>
</ul>
<p>以上代码由于返回一个保存外部环境的匿名函数，导致i的没有被释放，i的值被保存，之所以执行两次后i &#x3D;&#x3D;&#x3D; 2</p>
<ul>
<li>闭包由函数与其相关的引用环境组合而成</li>
<li>闭包允许函数访问其引用环境中的变量(又称自由变量)</li>
<li>广义上说，所有JS的函数都可以称为闭包，因为JS函数在创建时保存了当前的词法环境</li>
</ul>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><ul>
<li>保存现场</li>
</ul>
<p>以下方式导致alert(i)只会是length的值</p>
<pre><code>function add(nodes) &#123;
    for (var i=0;i&lt;nodes.length;i++) &#123;
        nodes[i].onclick = function() &#123;alert(i);&#125;
&#125;&#125;
</code></pre>
<p>正确方式,每次执行调用helper(i)保存现场 </p>
<pre><code>function add(nodes)&#123;
    function helper(i)&#123;
        return function()&#123;alert(i);&#125;    
for (var i=0;i&lt;nodes.length;i++)&#123;
    nodes[i].onclick = helper(i)&#125;
&#125;
</code></pre>
<ul>
<li>封装</li>
</ul>
<ul>
<li>外部变量无法访问内部，内部可以访问外部</li>
<li><code>return&#123;&#125;</code>中添加匿名函数方法</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul>
<li><code>var a = &#39;a&#39;</code></li>
<li><code>window.a = &#39;a&#39;</code> 定义在window上的属性，可以使用Delete方法删除。</li>
<li>函数内<code>var a;</code> 同上</li>
<li>函数内<code>var a=b=&#39;a&#39;</code> b定义到全局上了</li>
<li>函数内<code>a=&#39;a&#39;</code> 定义为全局</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>对象中</p>
<ul>
<li>私有方法–访问–私有属性、公有属性</li>
<li>公有方法–访问–私有方法、私有属性、公有属性</li>
</ul>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>无信息隐藏</p>
<pre><code>function a()&#123;
    this.a=null;this.step1=function()&#123;&#125;&#125; 

function a()&#123;
    thisa=null&#125;  
var pro=a.prototype;
pro.step=function()&#123;&#125;
</code></pre>
<p>信息隐藏(外部无法访问,由人为约束)</p>
<pre><code>function a()&#123;
    var _a=[&#39;a&#39;];
    this.getConfig=function()&#123;
        return _a;&#125;&#125;
pro._step=function()&#123;&#125;
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类继承						</p>
<pre><code>(function () &#123;
    function ClassA() &#123;&#125;
    ClassA.classMethod = function () &#123;&#125;;

    function ClassB() &#123;
    ClassA.apply(this,arguments);
        &#125;

    ClassB.prototype = new ClassA();
    ClassB.prototype.constructor = ClassB;
    ClassB.prototype.api = function () &#123;
        ClassA.prototype.api.apply(this,arguments);
        &#125;;

    var b = new ClassB();
    b.api();
    &#125;)();
</code></pre>
<p>ClassA是父类，ClassB是子类<br>原型继承</p>
<pre><code>(function () &#123;
    var proto = &#123;
        action1: function () &#123;&#125;,
        action2: function () &#123;&#125;
    &#125;;
    var obj = Object.create(proto);
&#125;)();
</code></pre>
<p>不支持ES5原型继承的解决方案</p>
<pre><code>var clone = (function () &#123;
    var F = function () &#123;&#125;;
    return function (proto) &#123;
        F.prototype = proto;
        return new F();
    &#125;
&#125;)();
</code></pre>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/05/20/14.%E6%9E%B6%E6%9E%84/"><i class="fa fa-chevron-left">  </i><span>页面架构笔记</span></a></div><div class="next-post pull-right"><a href="/2017/05/15/11.hasOwnProperty/"><span>hasOwnProperty被遮蔽的问题</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2024 By Doug Flands</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">+1S</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>
<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript笔记"><meta name="keywords" content="JS"><meta name="author" content="Doug Flands"><meta name="copyright" content="Doug Flands"><title>JavaScript笔记 | Flands Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#其他代码说明"><span class="toc-number">1.</span> <span class="toc-text">其他代码说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#语句"><span class="toc-number">2.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if语句"><span class="toc-number">2.1.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择语句"><span class="toc-number">2.2.</span> <span class="toc-text">选择语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环遍历"><span class="toc-number">2.3.</span> <span class="toc-text">循环遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">2.4.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.5.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件方法"><span class="toc-number">3.</span> <span class="toc-text">事件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#弹出提示"><span class="toc-number">3.1.</span> <span class="toc-text">弹出提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打开新窗口"><span class="toc-number">3.2.</span> <span class="toc-text">打开新窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件"><span class="toc-number">3.3.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间对象"><span class="toc-number">3.4.</span> <span class="toc-text">时间对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">3.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学方法"><span class="toc-number">3.6.</span> <span class="toc-text">数学方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象方法"><span class="toc-number">3.7.</span> <span class="toc-text">对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">3.8.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则"><span class="toc-number">3.9.</span> <span class="toc-text">正则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSON"><span class="toc-number">4.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS高级篇"><span class="toc-number">4.1.</span> <span class="toc-text">JS高级篇</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型"><span class="toc-number">5.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始类型和对象类型"><span class="toc-number">5.1.</span> <span class="toc-text">原始类型和对象类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式类型转换"><span class="toc-number">5.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式类型转换结果-特殊"><span class="toc-number">5.3.</span> <span class="toc-text">隐式类型转换结果(特殊)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型识别"><span class="toc-number">6.</span> <span class="toc-text">类型识别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-number">6.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">6.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-number">6.3.</span> <span class="toc-text">Object.prototype.toString.call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">6.4.</span> <span class="toc-text">constructor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数-1"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数定义"><span class="toc-number">7.1.</span> <span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#function-a-函数声明"><span class="toc-number">7.1.1.</span> <span class="toc-text">function a(){}  函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-a-function-函数定义"><span class="toc-number">7.1.2.</span> <span class="toc-text">var a = function (){}  函数定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用"><span class="toc-number">7.2.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arguments"><span class="toc-number">7.2.1.</span> <span class="toc-text">arguments</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数传参"><span class="toc-number">7.3.</span> <span class="toc-text">函数传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#first-class-function"><span class="toc-number">7.4.</span> <span class="toc-text">first-class function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原型"><span class="toc-number">8.</span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方式"><span class="toc-number">8.1.</span> <span class="toc-text">构造方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-number">8.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量作用域"><span class="toc-number">8.3.</span> <span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">9.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包的应用"><span class="toc-number">9.1.</span> <span class="toc-text">闭包的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象"><span class="toc-number">10.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#全局变量"><span class="toc-number">10.1.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#封装"><span class="toc-number">10.2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义方法"><span class="toc-number">10.2.1.</span> <span class="toc-text">定义方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">10.3.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://flands.com/avatar/192.jpg"></div><div class="author-info__name text-center">Doug Flands</div><div class="author-info__description text-center">Flands</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Flands Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">JavaScript笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-05-15</time></div><div class="article-container" id="post-content"><p>笔记标题啥的有点乱，就这样看吧，注释也有。</p>
<h1 id="其他代码说明"><a href="#其他代码说明" class="headerlink" title="其他代码说明"></a>其他代码说明</h1><pre><code>`&lt;li&gt;第${j+1}&lt;/li&gt;`                    //${}
&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
console.log()                        //输出日志
</code></pre><a id="more"></a>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><pre><code>if(str) {}
else if() {}
else {}
a&lt;1?为真结果:为假结果
</code></pre><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><pre><code>switch() {
case &apos;1&apos;: 代码 break;
default:都不符合;}
</code></pre><h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><pre><code>for(var i=0;i&lt;=Class.length;i++){
            Class[i].checked=true;        //选中
        }
while(){}
do{    }while()
</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><pre><code>try{if() throw &quot;自定义的错误提示&quot;}
catch(){}
finally{无论如何都执行}
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>function aaaa()
  {
     alert(&quot;调用函数&quot;);
  }
var length = arguments.length        //多个传参

&lt;input type=&quot;button&quot;  value=&quot;点击我&quot; onclick=&quot;aaaa();&quot; /&gt;  

参数传递
值传递只传递值，参数为对象时是引用传递

function P(x,y){
    this.x = x;
    this.y = y;
//公共方法
P.prototype.move = function(sX,sY){
    this.x += sX;
    this.y += sY;
}
}

var point = new P(1,1)        //point以P为原型克隆创建函数，这种方法避免P.move输出function
P.move(2,1)                    //从公共属性里查找方法
</code></pre><h1 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h1><h2 id="弹出提示"><a href="#弹出提示" class="headerlink" title="弹出提示"></a>弹出提示</h2><pre><code>alert(&quot;str&quot;);                        //弹出提示字符串
alert(hello);                        //弹出提示变量
prompt(&quot;提示&quot;，&quot;默认输入值&quot;)；            //可输入值对话框
confirm(&quot;str&quot;)；                        //消息确定取消对话框
</code></pre><h2 id="打开新窗口"><a href="#打开新窗口" class="headerlink" title="打开新窗口"></a>打开新窗口</h2><pre><code>window.open(&apos;URL&apos;, &apos;窗口名称&apos;, &apos;参数字符串&apos;)
名称.close();        //关闭

窗口名称
_blank：在新窗口显示目标网页
_self：在当前窗口显示目标网页
_top：框架网页中在上部窗口中显示目标网页
</code></pre><table>
<thead>
<tr>
<th>代码</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>top(width)</td>
<td>Number</td>
<td>方向上间隔像素</td>
</tr>
<tr>
<td>menubar</td>
<td>yes,no</td>
<td>菜单</td>
</tr>
<tr>
<td>toolbar</td>
<td>yes,no</td>
<td>工具条</td>
</tr>
<tr>
<td>scrollbars</td>
<td>yes,no</td>
<td>滚动条</td>
</tr>
<tr>
<td>status</td>
<td>yes,no</td>
<td>状态栏</td>
</tr>
</tbody>
</table>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>onclick         //鼠标单击
onmouseover      //鼠标经过
onmouseout         //鼠标移开
onchange         //文本框内容改变
onselect        //文本框内容被选中
onfocus            //光标聚集
onblur            //光标离开
onload            //网页导入
onunload        //关闭网页
</code></pre><h2 id="时间对象"><a href="#时间对象" class="headerlink" title="时间对象"></a>时间对象</h2><pre><code>var date = new Date(2012, 10, 1);    //获取时间
date.get/set     返回\设置    
FullYear()        //年份(四位数表示)
Year()            //年份
Month()            //月，0为1月
Date()            //日
Hours()            //小时，24制
Minutes()        //分钟
Seconds()        //秒钟
Time()            //时间(毫秒计)，以此转为num后传入new Date()即可
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code>string
String()                                //转数字
\&quot;                                        //转义
.toLowerCase()                            //转为小写字母
.toUpperCase()                            //转为大写字母
.charAt(string.length-1)                //返回最后一个字符
.indexOf(a, b)                            //检索a(区分大小写)，从b位置找，可设.length-1
.indexOf(&quot;o&quot;,string.indexOf(&quot;o&quot;)+1))    //检索第二个,当无时，返回-1
.split(&quot;&quot;,3)                            //分割每个字符，分割3次，可为正则
.slice(起点,终点(可为-1))                    //和下面一样
.substring( 起点 ， 终点(不包含)? )
.substr(起点,长度)
.search(re)                            //正则，返回索引位置，未找到为-1
.match(re)                            //返回匹配到的字符，+g为全局，返回所有，未找到为null
.replace(re|字符串,替换字符串)      //.replace(/\s+/g, &quot;&quot;)替换空字符串
</code></pre><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><pre><code>parseInt(&apos;&apos;)                    //字符串转整数,遇到字母停止转换
parseFloat(&apos;&apos;)                    //字符串转浮点
Number(&apos;100.1&apos;)                    //有字母就NaN
(100.123).toFixed(2)               //保留小数点
</code></pre><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><pre><code>.constructor()                //获取对象由哪种方法构造
.toString()                    //转字符串方法
.hasOwnprorerty(&quot;属性&quot;)        //是否包含某种属性，返回布尔值
</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>arr

原始数组被改变
.forEach()                    //遍历数组，传入函数fun(item){a.b +=5;}
.reverse()                    //倒序
.sort()                        //排序，a-b低-高，b-a高-低
.push()                        //在最后添加数组
.unshift()                    //在最前添加数组
.shift()                    //取出第一个元素，且被删除
.pop()                        //取出最后一个元素，且被删除
.splice(索引位置，删掉几个，插入元素)

对原数组没有修改
.slice(包含开始，不包含结束)    //获取索引数组数据
newArr.concat()                    //合并数组
.join(&quot;;&quot;)                    //合并数组，用分号隔开
.map(函数)                    //返回新的数组
.reduce(函数,初始值)            //返回一个数值，求和
</code></pre><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><pre><code>/1/.test(&apos;1&apos;)                //返回true|flase，只要包含则true
</code></pre><table>
<thead>
<tr>
<th>匹配一个位置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>起始位置</td>
</tr>
<tr>
<td>$</td>
<td>结尾位置</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>匹配一类字符串</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>abc中一个</td>
</tr>
<tr>
<td>[0-9]</td>
<td>一个数字</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>非数字的一个字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>一个字母</td>
</tr>
<tr>
<td>.</td>
<td>任一字符(换行除外)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>特殊意义的字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>等价[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>空白符</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>[A-Za-z0-9]</td>
</tr>
<tr>
<td>(a</td>
<td>b)或[ab]</td>
<td>匹配a或b</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>{m,n}</td>
<td>m到n次</td>
</tr>
<tr>
<td>*</td>
<td>无穷次{0,}</td>
</tr>
<tr>
<td>?</td>
<td>{0,1}</td>
</tr>
<tr>
<td>+</td>
<td>{1,}</td>
</tr>
<tr>
<td>\w</td>
<td>[A-Za-z0-9]</td>
</tr>
</tbody>
</table>
<p>一般添加’.’来匹配到换行符，然后返回false开始回溯<br>贪婪模式:根据表达式去匹配尽可能多的内容。回溯:当匹配为false时则回溯到倒数第一个true，返回结果</p>
<p>非贪婪模式(惰性模式)，添加’?’:匹配尽可能少的内容。回溯:匹配到第一个true就结束</p>
<p>独占模式，添加’+’:同贪婪，匹配为false不会回溯，直接结束匹配</p>
<table>
<thead>
<tr>
<th>捕获</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td>捕获</td>
</tr>
<tr>
<td>(?:)</td>
<td>不捕获</td>
</tr>
</tbody>
</table>
<pre><code>str.match(正则表达式)        //捕获字符串
str.replace(正则,&apos;替换内容$1&apos;)        //正则捕获的结果保存在$里，如果捕获5，则自动改为$5
</code></pre><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><pre><code>JSON.parse(文本,转换函数?)                    //JSON转JS对象，IE6,7不支持
JSON.stringify(数值,[想要传入的属性名称]?)        //JS对象转JSON
IE6.7支持方式
if (!window.JSON){
    window.JSON = {
        parse: function(sJSON){
            return eval(&apos;(&apos; +s.JSON+&apos;)&apos;);
        }
        stringify: function(){
            //...
        }
    };
}
</code></pre><h2 id="JS高级篇"><a href="#JS高级篇" class="headerlink" title="JS高级篇"></a>JS高级篇</h2><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="原始类型和对象类型"><a href="#原始类型和对象类型" class="headerlink" title="原始类型和对象类型"></a>原始类型和对象类型</h2><p>直接定义为原始类型，存储于栈内存<br><code>var a=123;</code>
栈内存的复制为深拷贝，创建新的内存值与变量   </p>
<p>对象类型存储于堆内存，{}[]
创建新对象为浅拷贝，指向原有变量的堆内存</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ul>
<li>数字+字符串=字符串</li>
<li><p>.转为对象类型</p>
<h2 id="隐式类型转换结果-特殊"><a href="#隐式类型转换结果-特殊" class="headerlink" title="隐式类型转换结果(特殊)"></a>隐式类型转换结果(特殊)</h2><p>|类型|原值|布尔|数字|
|—|—|—|—|
|Undefined|Undefined||NaN|
|Null|null||0|
|String|””|false|
|String|”la”||NaN|
|Number|NaN|false|
|Object|{}|true|NaN|
有数字的几乎都为true，false的Number为0，原值多少String就是多少，Object为类型+值。所有的对象都为true。<br>转换方式:Number(num.value)</p>
</li>
<li><p>Number(),String(),Boolean()</p>
</li>
<li>parseInt(),parseFloat()        //转为整数，浮点</li>
<li>!,!!        //两个!!取到对象的布尔值</li>
</ul>
<h1 id="类型识别"><a href="#类型识别" class="headerlink" title="类型识别"></a>类型识别</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><pre><code>typeof &quot;jerry&quot;;    //&quot;string&quot;
typeof undefined;//&quot;undefined&quot;
typeof null;//&quot;object&quot;
typeof {name:&quot;a&quot;};//&quot;object&quot;
typeof function(){}
</code></pre><ul>
<li>可以识别标准类型，Null除外</li>
<li>不能识别具体的对象类型，function除外</li>
</ul>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre><code>[] instanceof Array    //true
/\d/ instanceof RegExp //true
1 instanceof Number //false
&quot;jerry&quot; instanceof String //false
</code></pre><ul>
<li>判别所有对象类型</li>
<li>不能判别原始类型</li>
</ul>
<h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h2><pre><code>function type(obj){
    return Object.prototype.toString.call(obj).slice(8,-1)}
</code></pre><ul>
<li>识别标准类型以及内置对象类型</li>
<li>不能识别自定义的对象类型</li>
</ul>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><ul>
<li>构造对象的构造函数本身</li>
<li>判断标准类型(undefined/Null除外)</li>
<li>判别内置对象类型</li>
<li>判别自定义对象类型</li>
</ul>
<h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>JS执行前会解释部分代码</p>
<h3 id="function-a-函数声明"><a href="#function-a-函数声明" class="headerlink" title="function a(){}  函数声明"></a>function a(){}  函数声明</h3><ul>
<li>可以在函数定义前被调用(函数定义前置)</li>
<li>同名以最后的为准</li>
<li>作用域:逐级向上查询<h3 id="var-a-function-函数定义"><a href="#var-a-function-函数定义" class="headerlink" title="var a = function (){}  函数定义"></a>var a = function (){}  函数定义</h3></li>
<li>不能再函数定义前调用</li>
<li>作用域:只能访问本地作用域和全局作用域</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ul>
<li>函数调用模式 add(1)<br>this指向全局</li>
<li>方法调用模式 add.a(1)<br>this指向调用者</li>
<li>构造函数调用模式 <code>var a = new Function()</code><br>this指向被构造的对象</li>
<li>apply(call)调用模式<br>this指向第一个参数</li>
</ul>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><ul>
<li>Array-like<ul>
<li>arguments[index]</li>
<li>arguments.lenth</li>
</ul>
</li>
</ul>
<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><ul>
<li>按值传递<ul>
<li>原始类型变量</li>
</ul>
</li>
<li>按共享传递<ul>
<li>对象类型</li>
</ul>
</li>
</ul>
<h2 id="first-class-function"><a href="#first-class-function" class="headerlink" title="first-class function"></a>first-class function</h2><ul>
<li>函数作为参数<ul>
<li>异步回调函数</li>
</ul>
</li>
<li>函数作为返回值<ul>
<li><code>function.prororype.bind()</code>接受第一个参数，绑定在var对象中，执行var对象或者给var对象传入参数才会执行</li>
</ul>
</li>
<li>柯里化:接受一个参数,return一个函数用来接受余下函数</li>
</ul>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><ul>
<li>原型：以一个具体函数为对象创建一个对象</li>
<li>类:抽象出一个对象，以此创建一个类<h2 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h2></li>
<li>Object.create(proto)<ul>
<li>proto 一个对象，作为新创建对象的原型，原型为<em>proto</em></li>
</ul>
</li>
<li>构造函数<ul>
<li>使用prototype设置原型</li>
<li>使用new创建对象` var a = new b(‘’)</li>
<li>创建后构造函数中有原函数名的方法</li>
</ul>
</li>
<li><code>obj.hasOwnProperty(&#39;属性&#39;)</code>判断属性是否是自身的属性，返回布尔值<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2>构造出的的函数删除修改自身属性都不会影响原型，且可以访问原型上的方法</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li>静态作用域<ul>
<li>称为词法作用域</li>
<li>由程序定义的位置决定</li>
</ul>
</li>
<li>动态作用域<ul>
<li>查找栈内最后的对象</li>
</ul>
</li>
<li>词法环境<ul>
<li>形参</li>
<li>函数声明</li>
<li>变量</li>
<li>…</li>
</ul>
</li>
<li><p>环境记录初始化:声明提前，匿名函数指向父元素</p>
<ul>
<li>函数声明会因为初始化时而被定义作用域</li>
<li>函数定义会随着环境的改变而改变作用域<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1>子函数访问父函数的对象的作用域</li>
</ul>
</li>
<li><p>保存函数的执行状态</p>
</li>
<li>封装<ul>
<li>保存在return{}内使用各种方法</li>
</ul>
</li>
<li><p>性能优化</p>
<p>  function add(){</p>
<pre><code>var i = 0;
return function(){
    alert(i++);
    }
</code></pre><p>  }
  var f= add();
  f();
  f();
以上代码由于返回一个保存外部环境的匿名函数，导致i的没有被释放，i的值被保存，之所以执行两次后i === 2</p>
</li>
<li><p>闭包由函数与其相关的引用环境组合而成</p>
</li>
<li>闭包允许函数访问其引用环境中的变量(又称自由变量)</li>
<li>广义上说，所有JS的函数都可以称为闭包，因为JS函数在创建时保存了当前的词法环境<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2></li>
<li>保存现场</li>
</ul>
<p>以下方式导致alert(i)只会是length的值</p>
<pre><code>function add(nodes) {
    for (var i=0;i&lt;nodes.length;i++) {
        nodes[i].onclick = function() {alert(i);}
}}
</code></pre><p>正确方式,每次执行调用helper(i)保存现场 </p>
<pre><code>function add(nodes){
    function helper(i){
        return function(){alert(i);}    
for (var i=0;i&lt;nodes.length;i++){
    nodes[i].onclick = helper(i)}
}
</code></pre><ul>
<li>封装<ul>
<li>外部变量无法访问内部，内部可以访问外部</li>
<li><code>return{}</code>中添加匿名函数方法</li>
</ul>
</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul>
<li><code>var a = &#39;a&#39;</code></li>
<li><code>window.a = &#39;a&#39;</code> 定义在window上的属性，可以使用Delete方法删除。</li>
<li>函数内<code>var a;</code> 同上</li>
<li>函数内<code>var a=b=&#39;a&#39;</code> b定义到全局上了</li>
<li><p>函数内<code>a=&#39;a&#39;</code> 定义为全局</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>对象中</p>
</li>
<li><p>私有方法–访问–私有属性、公有属性</p>
</li>
<li><p>公有方法–访问–私有方法、私有属性、公有属性</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>无信息隐藏</p>
<p>  function a(){</p>
<pre><code>this.a=null;this.step1=function(){}} 
</code></pre><p>  function a(){</p>
<pre><code>thisa=null}  
</code></pre><p>  var pro=a.prototype;
  pro.step=function(){}</p>
</li>
</ul>
<p>信息隐藏(外部无法访问,由人为约束)</p>
<pre><code>function a(){
    var _a=[&apos;a&apos;];
    this.getConfig=function(){
        return _a;}}
pro._step=function(){}
</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类继承                        </p>
<pre><code>(function () {
    function ClassA() {}
    ClassA.classMethod = function () {};

    function ClassB() {
    ClassA.apply(this,arguments);
        }

    ClassB.prototype = new ClassA();
    ClassB.prototype.constructor = ClassB;
    ClassB.prototype.api = function () {
        ClassA.prototype.api.apply(this,arguments);
        };

    var b = new ClassB();
    b.api();
    })();
</code></pre><p>ClassA是父类，ClassB是子类<br>原型继承</p>
<pre><code>(function () {
    var proto = {
        action1: function () {},
        action2: function () {}
    };
    var obj = Object.create(proto);
})();
</code></pre><p>不支持ES5原型继承的解决方案</p>
<pre><code>var clone = (function () {
    var F = function () {};
    return function (proto) {
        F.prototype = proto;
        return new F();
    }
})();
</code></pre></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/05/20/14.架构/"><i class="fa fa-chevron-left">  </i><span>页面架构笔记</span></a></div><div class="next-post pull-right"><a href="/2017/05/15/11.hasOwnProperty/"><span>hasOwnProperty被遮蔽的问题</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Doug Flands</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">+1S</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>